\documentclass{article}
\usepackage[german]{babel}
\usepackage{float}
\usepackage{fourier}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsfonts,amsthm, amsmath}
\usepackage{listings}
% The following is needed in order to make the code compatible
% with both latex/dvips and pdflatex.
\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

\setlength\parindent{0pt}
\lstset{language=Erlang}

\begin{document}

\textbf{Team:} Falco Winkler (FW), Daniel Schruhl (DS)\\
\\
\textbf{Aufgabenteilung:}\\

\textbf{Quellenangaben:}\\
\\
\textbf{Bearbeitungszeitraum:}
\begin{itemize}
	\item 26.03.2017 (FW,DS)
	\item 03.04.2017 (DS)
\end{itemize}

\textbf{Aktueller Stand:}\\

\textbf{Änderung des Entwurfs:}\\
\begin{itemize}
	\item Komponentendiagramm erweitert
\end{itemize}

\newpage
\tableofcontents 
\newpage

\section{Einführung und Ziele}
Es soll eine Message of the Day Anwendung erstellt werden. Dabei werden von verschiedenen Clients an einen Server verschiedene Nachrichten des Tages gesendet. Die Clients rufen vom Server alle Nachrichten ab, so dass jeder Client alle Nachrichten in einer festen Reihenfolge hat.

\subsection{Randbedingungen}
Es soll eine Client/Server-Architektur implementiert werden.
Der Server verwaltet dabei die ihm von den Clients gesendeten Nachrichten. Das beinhaltet eine feste Numerierung der Nachrichten.

Die Clients rufen dabei in bestimmten Abständen die Nachrichten ab. Falls ein Client dem Server schon bekannt ist, bekommt der nur die ihm noch unbekannten (neuen) Nachrichten.

Der Server muss sich also die Clients merken. Es soll mit einer Holdbackqueue und einer Deliveryqueue gearbeitet werden, um die korrekte Auslieferung in einer bestimmten Reihenfolge der Nachrichten zu garantieren.

\subsection{Kontextbegrenzung}
Das System soll in Erlang umgesetzt werden. Es muss auf Computern mit Linux Betriebssystem lauffähig sein.

\newpage

\section{Gesamtsystem}
\subsection{Kontextsicht}

\subsection{Bausteinsicht}
Das Softwareprodukt besteht aus mehreren Modulen und Paketen (Abbildung \ref{fig:component-diagram}). Diese Pakete setzen sich zusammen aus dem Client-Paket und dem Server-Paket.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{component-diagram.png}
    \caption[seq-dia]{Komponentendiagramm der Message Of The Day App}
    \label{fig:component-diagram}
\end{figure}

Das Server Paket beinhaltet das Server-Modul und alle vom Server-Modul verwendeten Datenstrukturen.\\
Das Server-Modul ist für alle Funktionalitäten des Servers zuständig. Dazu gehört das Nummerieren und Verwalten der Nachrichten und die Verwaltung der Clients.\\
Das Server-Modul benutzt daher per Schnittstelle das HBQ-Modul und das CMEM-Modul. Das Server-Modul stellt eine Schnittstelle für die Clients bereit.\\
\\
Das CMEM-Modul ist für die Speicherung der Clients und ihrer aktuellen zu erwartenden Nachrichten Nummer zuständig. Das CMEM-Modul soll als lokale ADT realisiert werden. Diese wird nur vom Server angesprochen.\\
\\
Das HBQ-Modul ist für die Holdbackqueue zuständig und regelt die Sortierung der einkommenden Nachrichten in die Deliveryqueue und der damit verbundenen Fehlerbehandlung. Dabei ist das HBQ-Modul als entfernte ADT realisiert. Diese wird nur von dem Server-Modul verwendet.\\
\\
Das DLQ-Modul realsiert die Deliveryqueue, die für die Auslieferung der Nachrichten in Reihenfolge an die Clients zuständig ist. Die Schnittstelle des DLQ-Moduls wird nur vom HBQ-Modul konsumiert.\\
\\
Das Client-Paket beinhaltet die Client-Module. Diese sind zum einen der Lese Client (Reader-Modul) und der Redakteur Client (Editor-Modul). Beide Clients sind als ein Prozess implementiert und verwenden die vom Server bereitgestellte Schnittstelle. Der Redakteur Client ist für das Schicken von Nachrichten zuständig und der Lese Client für das Lesen von Nachrichten.

\subsection{Laufzeitsicht}
\begin{figure}[H]
\centering
\includegraphics[width=\textwidth]{sequence-diagram.png}
\caption[seq-dia]{Sequenzdiagramm bei fehlerfreiem Nachrichtenaustausch}
\label{fig:sequence-diagram}
\end{figure}

\subsection{Verteilungssicht}


\subsection{Konfigurationsparameter}


\subsection{Benutzungsschnittstelle}

\newpage
\section{Subsysteme und Komponenten}
\subsection{Client}
\subsubsection{Aufgabe und Verantwortung des Clients}
Der Client ist ein einzelner Prozess, der sich jedoch in zwei Rollen aufteilt. Im Endlosdurchlauf einer Schleife wechselt er zwischen Leser und Redakteur - Rolle.\\

Der Client wird in drei Module aufgespalten: Client, Reader und Writer. Client ruft in einer Endlosschleife wechselweise die soeben beschriebene Funktionalität in den Modulen Reader und Writer auf.

\subsubsection{Entwurfsentscheidungen}
\subsubsection{Außensicht}
\subsubsection{Innensicht}
\subsubsection{Konfigurationsparameter}
\subsubsection{Komponente Leserclient}
    	
    		\paragraph{Aufgabe und Verantwortung des Leseclients}
    		Der Leseclient liest solange Nachrichten vom Server, 
    		bis keine weiteren Nachrichten mehr vorhanden sind.
			\paragraph{Entwurfsentscheidungen}
			\paragraph{Außensicht}
			\paragraph{Innensicht}
			\paragraph{Konfigurationsparameter}
		
		\subsubsection{Komponente Redakteurclient}
		
		    \paragraph{Aufgabe und Verantwortung des Redakteurclients}
		    Der Redakteurclient sendet fünf Nachrichten an den Server, 
		    und fragt danach einmal die nächste NNr ab, um eine Lücke in den fortlaufend 
		    nummerierten Nachrichten zu produzieren.
			\paragraph{Entwurfsentscheidungen}
			\paragraph{Außensicht}
			\paragraph{Innensicht}
			\paragraph{Konfigurationsparameter}
			
	\subsection{Server}
	
		\subsubsection{Aufgabe und Verantwortung des Servers}
			Der Server hat die Aufgaben  
			\begin{enumerate}
    			\item{Sich anfragende Clients mit ProzessID und Zeitstempel zu merken}
    			\item{Clients die ihnen zugehörigen Nachrichten zurückzugeben}
			\end{enumerate}
			Für die erste Aufgabe wird das Modul CMEM verwendet. 
			Zum Senden an die Clients leitet der Server die Nachrichten zunächst an die HBQ weiter. 
			Erscheint eine Anfrage vom Client, erfolgt über die HBQ der Aufruf an die DLQ, 
			die Nachricht zu übermitteln.
		\subsubsection{Entwurfsentscheidungen}
			Der Server bearbeitet Anfragen per message passing. Die NNr ist ein Zählerwert,
			der nach jedem Herausgeben an einen Client inkrementiert wird.
		\subsubsection{Außensicht}
			Es werden Schnittstellen zur Abfage der aktuellen NNr, zum Holen & Speichern 
			von Nachrichten bereitgestellt. Nach einer bestimmten, aber nach Außen unbekannten 
			Zeit werden auch bereits abgeholte Nachrichten ausgeliefert.
		\subsubsection{Innensicht}
			Anfragen werden in einer Endlosschleife abgefragt und nur an die jeweiligen 
			Komponenten weitergeleitet. Fehlerbehandlung erfolgt in den jeweiligen Komponenten.
			Bei jeder Anfrage erfolgt die Abfrage & Aktualisierung der CMEM,
			um sich den anfragenden Client zu merken und Anfragen an die HBQ korrekt zu stellen.
			
		\subsubsection{Konfigurationsparameter}
			\begin{enumerate}
    			\item{Latenzzeit bestimmt die maximale Zeit die der Server ungenutzt läuft.}
    			\item{Lebenszeit des Clients bestimmt die Zeit, für die sich der Server einen 
    					Client merkt.}
    			\item{Name definiert den Namen der Server - Node}
    			\item{HBQ - Name & Node definieren die Verknüpfung zur HBQ - Node}
    		\end{enumerate}
		\subsubsection{Benutzungsschnittstelle}
			Der Server wird nur durch seine Schnitstellen vom Client verwendet.
		\subsubsection{Komponente CMEM}
			\paragraph{Aufgabe und Verantwortung der CMEM}
				Dieses Modul hat die Aufgabe sich anfragende Clients mittels einer ProzessID und eines Zeitstempels zu merken, und diese für den Server bereitzustellen.
			\paragraph{Entwurfsentscheidungen}
				Als Datenstruktur wird ein Dictionary verwendet. Jeder Client wird mittels
				seiner ProzessID eindeutig auf einen Offset und auf einen Zeitstempel der 
				letzten Anfrage abgebildet. Der Offset wird verwendet, um sich zu merken, 
				welche Nachricht als letztes an den Client gesendet wurde.
			\paragraph{Außensicht}
				Die CMEM wird nur über Funktionsaufrufe durch den Server aufgerufen.
			\paragraph{Innensicht}
				Intern arbeiten die Methoden deleteIdleClients und insertOrUpdateClient
				auf der Datenstruktur. getTimestampAndOffset gibt für einen Client den Entsprechenden
				Offset und Timestamp zurück. Nur der Server verarbeitet die zurückgegebenen Werte.
			\paragraph{Konfigurationsparameter}
				-
			
			
		\subsubsection{Komponente HBQ}
			\paragraph{Aufgabe und Verantwortung der HBQ}
				Von Redakteur-Clients gesendete Nachrichten werden hier zwischengespeichert. Gibt es keine Lücke in der fortlaufenden Nummerierung der Nachrichten, werden Sie an die DLQ weitergeleitet. Bei einer Überfüllung der HBQ (2/3 der Maximalen Kapazität der DLQ) wird die älteste Lücke in den Nachrichten mit einer künstlichen Nachricht geschlossen, und es werden erneut alle Lückenlosen Nachrichten an die DLQ weitergeleitet. Die HBQ stellt nur ein Interface für den Server bereit.
			\paragraph{Entwurfsentscheidungen}
			\paragraph{Außensicht}
			\paragraph{Innensicht}
			\paragraph{Konfigurationsparameter}
				\begin{enumerate}
    				\item{Die Maximalgröße der DLQ wird verwendet um die HBQ bei kritischer 
    				Überfüllung zu leeren.}
    			\end{enumerate}
			
		\subsubsection{Komponente DLQ}
			\paragraph{Aufgabe und Verantwortung der DLQ}
				Die Delivery - Queue hat die Aufgabe Nachrichten an Clients zuzustellen. 
				Die Nachrichten in der DLQ liegen immer sortiert vor, und es gibt keine Lücken in den NNr’s.
				Bei dem Sendevorgang erhält die DLQ ein Signal von der HBQ mit der PID des Ziel - Clients und der Nachrichtennummer. Daraufhin wird die Nachricht mit dieser NNr an den Client verschickt.
				Wenn diese Nachricht nicht vorhanden ist wird die Nachricht mit der nächst höheren NNr verschickt. 
				Es wird jeweils die Nummer der verschickten Nachricht zurückgegeben.
			\paragraph{Entwurfsentscheidungen}
			\paragraph{Außensicht}
			\paragraph{Innensicht}
			\paragraph{Konfigurationsparameter}
				

\subsubsection{Schnittstelle}
\begin{lstlisting}[language=erlang]
/* Initialisieren der DLQ */
initDLQ(Size,Datei): Integer X Atom -> DQueue

/* Abfrage welche Nachrichtennummer in der DLQ gespeichert werden kann */
expectedNr(Queue) : DQueue -> Integer

/* Speichern einer Nachricht in der DLQ */
push2DLQ([NNr,Msg,TSclientout,TShbqin],Queue,Datei) :
    MSG_list X DQueue X Atom -> DQueue

/* Ausliefern einer Nachricht an einen Leser-Client */
deliverMSG(MSGNr,ClientPID,Queue,Datei):
    Integer X PID X DQueue X Atom -> Integer
\end{lstlisting}

\subsubsection{Entwurfsentscheidungen}
Die Deliveryqueue wird als Erlang Liste realisiert. Das erste Element der Liste ist dabei eine Liste der Nachrichten und das zweite Element der Liste gibt die Kapazität der DLQ an.
\begin{lstlisting}[language=erlang]
/* Nachrichten Format */
/* minimal 3 Elemente, pro Station kommt eins hinzu; maximal 6 Elemente */
MSG_List := [NNr,Msg,TSclientout,TShbqin,TSdlqin,TSdlqout]:
    [Integer X String X 3-Tupel X 3-Tupel X 3-Tupel X 3-Tupel]

/* DLQ Format */
/* Nachrichtenliste ist eine Liste aus Nachrichten und hat */
/* maximal Kapazitaet Anzahl an  Elementen */
DLQ := [Nachrichtenliste, Kapazitaet]: [List X Integer]
\end{lstlisting}

Neue Nachrichten werden am Anfang der Liste angefügt. Das vereinfacht die Nachfrage nach der nächsten zu speichernden Nachrichtennummer in der DLQ. Demnach werden Nachrichten am Ende der Liste entnommen.

Das kann passieren, wenn die Größe der Liste gleich ihrer Kapazität ist und eine Neue Nachricht hinzugefügt werden soll.

\paragraph{Konfigurationsparameter}
\begin{itemize}
    \item Kapazität der DLQ
\end{itemize}

\end{document}