\documentclass{article}
\usepackage[german]{babel}
\usepackage{float}
\usepackage{fourier}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsfonts,amsthm, amsmath}
\usepackage{listings}
% The following is needed in order to make the code compatible
% with both latex/dvips and pdflatex.
\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

\setlength\parindent{0pt}
\lstset{language=Java}

\begin{document}

\textbf{Team:} TEAM 01, Falco Winkler (FW), Daniel Schruhl (DS)\\
\\
\textbf{Aufgabenteilung:}
\begin{itemize}
    \item IDL Compiler
    \item Namensdienst
    \item mware\_lib Library
\end{itemize}

\textbf{Quellenangaben:}
\begin{itemize}
    \item Aufgabe 4, 11.06.2017, C. Klauck \& H. Schulz: \newline
    http://users.informatik.haw-hamburg.de/~schulz/pub/Verteilte-Systeme/AI5-VSP/Aufgabe4/
\end{itemize}

\textbf{Bearbeitungszeitraum:}
\begin{itemize}
	\item 11.06.2017 4 Stunden (DS)
	\item 12.06.2017 2 Stunden (DS)
	\item 14.06.2017 4 Stunden (DS)
	\item 15.06.2017 5 Stunden (DS)
\end{itemize}

\textbf{Aktueller Stand:}
\begin{itemize}
	\item IDL Compiler fertig und getestet
    \item Namensdienst
    \item mware\_lib Library
\end{itemize}

\textbf{Änderung des Entwurfs:}
\begin{itemize}
    \item Keine Änderungen
\end{itemize}

\newpage

\section{Einführung und Ziele}
Es soll eine einfache objektorientierte Middleware entworfen werden, die Methodenaufrufe
eines entfernten Objektes ermöglicht.

Zur Orientierung gilt hierbei die CORBA Architektur. Genauer soll hier ein ORB zur
Verfügung gestellt werden, der es ermöglicht Methoden von entfernten Objekten aufzurufen.

Zur Abstraktion und Beschreibung der Schnittstellen der Objekte soll eine IDL verwendet werden.
Diese IDL wird dann zur Erzeugung von Klassen- und Methodenrümpfen verwendet.

Außerdem beinhaltet der ORB einen Namensdienst, der Objektreferenzen in einem Netz mit Namen finden
kann.

Die Middleware an sich soll durch eine Library abstrahiert und verwendbar sein.

\subsection{Randbedingungen}
Der Namensdienst soll auf einem entfernten Rechner unabhängig von der Middleware Library
lauffähig sein. Der Port muss zur Laufzeit einstellbar sein.

Der IDL-Compiler soll in einem Package oder einer \texttt{.jar} Datei zur Verfügung gestellt
werden. Der Compiler soll folgende IDL Typen unterstützen:

\begin{itemize}
    \item module (keine Schachtelung, 1 Modul pro Datei)
    \item class (nicht als Parameter oder Returnwert, keine Schachtelung)
    \item int
    \item double
    \item string
\end{itemize}

Ein Beispiel:
\begin{lstlisting}
module math_ops {
  class Calculator {
   double add(double a, double b);
   string getStr(double a);
 };
};
\end{lstlisting}

Die Middleware Library soll in einem Package \texttt{mware\_lib} zusammengefasst werden.

Wenn eine Serverapplikation während eines entfernten Methodenaufrufes eine RuntimeException
wirft, soll diese an den Aufrufer weitergeleitet werden.

Es soll möglich sein, dass zwei oder mehrere Klienten die selbe Objektreferenz zeitgleich
nutzen wollen. Das soll innerhalb der Middleware nicht zu Deadlocks führen.

\subsection{Kontextbegrenzung}
Die Implementierung soll in Java vorliegen.

Die Behebung von Deadlocks in den Anwendungen ist nicht Aufgabe der Middleware.

\newpage

\section{Gesamtsystem}
Das Gesamtsystem besteht aus drei Subsystemen, die unabhängig voneinander lauffähig sind.
Dabei sind das NameService System und das IDL-Compiler System Applikationen, die über
die Kommandozeile gestartet werden können.

Die Middleware Library (mware\_lib) ist eine Bibliothek, die in der jeweiligen Applikation,
die die Middleware verwenden soll eingebunden werden muss. Die Middleware Library ist also
nicht direkt über die Kommandozeile startbar.

\subsection{Bausteinsicht}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{compiler-components.png}
    \caption[compiler-components]{Komponentendiagramm des IDL-Compilers (Neptr)}
    \label{fig:compiler-component-diagram}
\end{figure}

\subsection{Laufzeitsicht}
%\begin{figure}[H]
%    \centering
%    \includegraphics[width=1.0\textwidth]{sequence-diagram.png}
%    \caption[seq-dia]{Eine ggT Berechnung mit Abbruch per Voting}
%    \label{fig:seq-diagram}
%\end{figure}

\newpage

\section{Subsysteme und Komponenten}

\subsection{NameService}
\subsubsection{Aufgabe und Verantwortung}
Der NameService bildet Namen auf Objektreferenzen ab. Er wird verwendet, um Objekte anhand
ihres Namens zu finden und anzusprechen und um Objekte anzumelden.

\subsubsection{Schnittstelle}
\begin{lstlisting}
Die Schnittstellen sind ansprechbar mittels u.g. 
Nachrichtenformat per TCP an gegebenem Port. 
public void rebind(Object servant, String name); 
Bindet ein Objekt an einen Platzhalter im Namensdienst.
public Object resolve(String name); 
Loest eine Namensreferenz auf ein Java - Objekt auf.
Das Ergebnis wird als serialisiertes Java - Objekt per TCP an den Aufrufer gesendet.
\end{lstlisting}

\subsubsection{Entwurfsentscheidungen}
Der Port, an dem der NameService läuft ist zur Laufzeit einstellbar. Das geschieht über
den Startparameter.

Der Nameservice Empfängt Nachrichten im folgenden Format:
\begin{itemize}
\item Byte 0: Art des Befehls. (0 = Rebind, 1 = Resolve, 2 = Shutdown) 
\item Byte 1 - 11: Alias für rebind / resolve
\item Byte 12 - n: Serialisiertes Objekt
\end{itemize}

\subsubsection{Konfigurationsparameter}
\begin{itemize}
    \item Port des NameServices
\end{itemize}

\subsection{IDL Compiler}
\subsubsection{Aufgabe und Verantwortung}
Der IDL Compiler hat die Aufgabe, eine gegebene Modulbeschreibung aus einer \texttt{.idl-Datei} im IDL Format einzulesen
und daraus Java-Code zu generieren.\\

Es wird eine Abstrakte Klasse Java generiert (ImplBase bzw. Stub). Diese wird auf Serverseite eingebunden und zu einer
konkreten Klasse abgeleitet.\\

Darüber hinaus soll der Compiler eine Proxy - Klasse für die Clientseite generieren, welche die Methodenaufrufe auf dem
entfernten Server Objekt weiterleitet und ausführt. Das Proxy Objekt wird mit der Abstrakten Klasse (Stub) im Client
per narrowCast Methode erstellt.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Compiler_FDM.png}
    \caption[fdm-compiler]{Fachliches Daten Modell des IDL-Compilers}
    \label{fig:fdm-compiler}
\end{figure}

\subsubsection{Schnittstelle}
\begin{lstlisting}
public class Compiler {
    /**
     * Ueber die main - Methode der Klasse Compiler kann der Compiler ausgefuehrt werden.
     */
    public static void main(String[] args);
}
\end{lstlisting}
Zu übergebene Argumente sind:
\begin{itemize}
	\item args[0]: Pfad zur IDL - Datei
	\item args[1]: Pfad zum Ordner für die Ausgabedateien
\end{itemize}

Die erzeugten Binaries können wie folgt ausgeführt werden:\\

\texttt{./bin/neptr <IDL-Dateipfad> <Ausgabe-Ordner>}

\subsubsection{Entwurfsentscheidungen}
Der Compiler besteht aus vier Komponenten (siehe Abbildung \ref{fig:compiler-component-diagram}). In der
Hauptkomponente (Compiler) ist der eigentliche Compiler mit seiner Hauptmethode. Diese wird nach außen frei gegeben.

Der Compiler benutzt den Parser um eine IDL-Datei zu parsen und daraus ein IDLModule zu erstellen (siehe Abbildung
\ref{fig:fdm-compiler}). Diese IDLModule beinhaltet alle Klassen. Jede Klasse hat eine Ansammlung von Methoden.
Der Compiler schreibt nachdem die IDL-Datei geparsed wurde alle erkannten Klassen im Modul der IDL-Datei mit Hilfe der
Translator an den angegeben Ausgabepfad.\\

Die Translator haben ein fest definiertes Interface. Dadurch können leichter neue Translator erstellt werden und
Translator ausgetauscht werden. Außerdem ist dadurch der Übersetzungsprozess logisch von der Syntax der zu übersetzenden
Klasse getrennt.
Es gibt insgesamt zwei Translators. Einen um die Stubs (ImplBase) zu erstellen und einen
um die Proxy Klassen zu erstellen. Die Translators sind also dafür zuständig die IDLModules zu kompilieren in die
gewünschten Java Klassen.\\

Die Parser Komponente und die IDLModel Komponente wurden mit Hilfe der vorgegeben Klassen aus der Aufgabe erstellt und
erweitert.

\subsection{mware lib}
\subsubsection{Aufgabe und Verantwortung}
Die Bibiothek / das Package mware lib stellt die Kernfunktionalität bereit.
Die Schnitstelle nach außen ist die Klasse ObjectBroker, die eine Referenz auf eine
Implementierung des NameService Protokolls hält.


\subsubsection{Schnittstelle}
\begin{lstlisting}
public NameService getNameService();
Gibt die Referenz auf das Proxyobjekt fuer den NameService an den Aufrufer.
public void shutDown();
Beendet den Object Request Broker und seine Dependencies.
\end{lstlisting}

\subsubsection{Entwurfsentscheidungen}
Der Object Request Broker wird gemäß Vorgabe in einer statischen Methode initialisiert.
Hierbei wird ein Nameservice Proxyobjekt erzeugt, und zur weiteren Verwendung referenziert.
Das Nameservice Proxyobjekt leitet alle Methodenaufrufe des NameService an eine entfernte
NameService Instanz per TCP weiter.

\subsubsection{Konfigurationsparameter}

\begin{itemize}
    \item host: Der Hostname des entfernten NameService
    \item Port: Der Port des entfernten NameService
	\item Debug: Konfiguriert, ob debug ausgaben geloggt werden sollen.
\end{itemize}


\end{document}