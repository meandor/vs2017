\documentclass{article}
\usepackage[german]{babel}
\usepackage{float}
\usepackage{fourier}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsfonts,amsthm, amsmath}
\usepackage{listings}
% The following is needed in order to make the code compatible
% with both latex/dvips and pdflatex.
\ifx\pdftexversion\undefined
\usepackage[dvips]{graphicx}
\else
\usepackage[pdftex]{graphicx}
\DeclareGraphicsRule{*}{mps}{*}{}
\fi

\setlength\parindent{0pt}
\lstset{language=Java}

\begin{document}

\textbf{Team:} TEAM 01, Falco Winkler (FW), Daniel Schruhl (DS)\\
\\
\textbf{Aufgabenteilung:}
\begin{itemize}
    \item IDL Compiler
    \item Namensdienst
    \item mware\_lib Library
\end{itemize}

\textbf{Quellenangaben:}
\begin{itemize}
    \item Aufgabe 4, 11.06.2017, C. Klauck \& H. Schulz: \newline
    http://users.informatik.haw-hamburg.de/~schulz/pub/Verteilte-Systeme/AI5-VSP/Aufgabe4/
\end{itemize}

\textbf{Bearbeitungszeitraum:}
\begin{itemize}
	\item 11.06.2017 4 Stunden (DS)
	\item 12.06.2017 2 Stunden (DS)
	\item 14.06.2017 4 Stunden (DS)
	\item 15.06.2017 5 Stunden (DS)
	\item 15.06.2017 5 Stunden (DS)
\end{itemize}

\textbf{Aktueller Stand:}
\begin{itemize}
	\item IDL Compiler fertig und getestet
    \item Namensdienst fertig und getestet
    \item mware\_lib Library fertig und getestet
\end{itemize}

\textbf{Änderung des Entwurfs:}
\begin{itemize}
    \item Keine Änderungen
\end{itemize}

\newpage

\section{Einführung und Ziele}
Es soll eine einfache objektorientierte Middleware entworfen werden, die Methodenaufrufe
eines entfernten Objektes ermöglicht.\\

Zur Orientierung gilt hierbei die CORBA Architektur. Genauer soll hier ein ORB zur
Verfügung gestellt werden, der es ermöglicht Methoden von entfernten Objekten aufzurufen.\\

Zur Abstraktion und Beschreibung der Schnittstellen der Objekte soll eine IDL verwendet werden.
Diese IDL wird dann zur Erzeugung von Klassen- und Methodenrümpfen verwendet.\\

Außerdem beinhaltet der ORB einen Namensdienst, der Objektreferenzen in einem Netz mit Namen finden
kann.\\

Die Middleware an sich soll durch eine Library abstrahiert und verwendbar sein.

\subsection{Randbedingungen}
Der Namensdienst soll auf einem entfernten Rechner unabhängig von der Middleware Library
lauffähig sein. Der Port muss zur Laufzeit einstellbar sein.\\

Der IDL-Compiler soll in einem Package oder einer \texttt{.jar} Datei zur Verfügung gestellt
werden. Der Compiler soll folgende IDL Typen unterstützen:

\begin{itemize}
    \item module (keine Schachtelung, 1 Modul pro Datei)
    \item class (nicht als Parameter oder Returnwert, keine Schachtelung)
    \item int
    \item double
    \item string
\end{itemize}

Ein Beispiel:
\begin{lstlisting}
module math_ops {
  class Calculator {
   double add(double a, double b);
   string getStr(double a);
 };
};
\end{lstlisting}

Die Middleware Library soll in einem Package \texttt{mware\_lib} zusammengefasst werden.\\

Wenn eine Serverapplikation während eines entfernten Methodenaufrufes eine RuntimeException
wirft, soll diese an den Aufrufer weitergeleitet werden.\\

Es soll möglich sein, dass zwei oder mehrere Klienten die selbe Objektreferenz zeitgleich
nutzen wollen. Das soll innerhalb der Middleware nicht zu Deadlocks führen.

\subsection{Kontextbegrenzung}
Die Implementierung soll in Java vorliegen.

Die Behebung von Deadlocks in den Anwendungen ist nicht Aufgabe der Middleware.

\newpage

\section{Gesamtsystem}
Das Gesamtsystem besteht aus drei Subsystemen, die unabhängig voneinander lauffähig sind.
Dabei sind das NameService System und das IDL-Compiler System Applikationen, die über
die Kommandozeile gestartet werden können.

Die Middleware Library (mware\_lib) ist eine Bibliothek, die in der jeweiligen Applikation,
die die Middleware verwenden soll eingebunden werden muss. Die Middleware Library ist also
nicht direkt über die Kommandozeile startbar.

\subsection{Bausteinsicht}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{compiler-components.png}
    \caption[compiler-components]{Komponentendiagramm des IDL-Compilers (Neptr)}
    \label{fig:compiler-component-diagram}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{nameservice-components.png}
    \caption[nameservice-components]{Komponentendiagramm des NameServices Server (Enchiridion)}
    \label{fig:nameservice-component-diagram}
\end{figure}

\subsection{Laufzeitsicht}
%\begin{figure}[H]
%    \centering
%    \includegraphics[width=1.0\textwidth]{sequence-diagram.png}
%    \caption[seq-dia]{Eine ggT Berechnung mit Abbruch per Voting}
%    \label{fig:seq-diagram}
%\end{figure}

\newpage

\section{Subsysteme und Komponenten}

\subsection{NameService (Enchiridion)}
\subsubsection{Aufgabe und Verantwortung}
Der NameService bildet Namen auf Objektreferenzen ab. Er wird verwendet, um Objekte anhand
ihres Namens zu finden und anzusprechen und um Objekte anzumelden. Er besteht dabei aus einem Client und einem Server.

\subsubsection{Schnittstelle}
Die Schnittstellen zwischen dem Client und dem Server tauschen Nachrichten per TCP mittels
u.g. Nachrichtenformat (Entwurfsentscheidungen) an gegebenem Port aus.
\begin{lstlisting}
public abstract class NameService {

    /**
     * Registers an Object (servant) at the NameService
     *
     * @param servant Object to register
     * @param name    String representation of the object
     */
    public abstract void rebind(Object servant, String name);

    /**
     * Returns the Object reference from the given servant
     *
     * @param name String of servant
     * @return general Object reference
     */
    public abstract Object resolve(String name);
}

public class NameServiceStarter {
    /**
     * Ueber die main - Methode der Klasse NameServiceStarter
     * kann der NameService (Server) gestartet werden.
     */
    public static void main(String[] args);
}
\end{lstlisting}
Zu übergebene Argumente sind:
\begin{itemize}
	\item args[0]: Port auf dem der NameService Server laufen soll
\end{itemize}

Die erzeugten Binaries können wie folgt ausgeführt werden:\\

\texttt{./bin/enchiridion <Port>}

\subsubsection{Entwurfsentscheidungen}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{nameservice-fdm.png}
    \caption[fdm-nameservice]{Fachliches Daten Modell des NameServices}
    \label{fig:fdm-nameservice}
\end{figure}

Der NameService an sich besteht aus einem Server, der Anfragen entgegennehmen kann.
Der Client des NameServices ist in der Middleware enthalten.

Der Port, an dem der NameService läuft ist zur Laufzeit einstellbar. Das geschieht über den Startparameter.\\

Der Nameservice Empfängt Nachrichten im folgenden Format:
\begin{itemize}
\item Byte 0: Art des Befehls. (0 = Rebind, 1 = Resolve)
\item Byte 1 - 11: Alias für rebind / resolve
\item Byte 12 - n: Serialisiertes Referenz Objekt, nur für rebind benötigt
\end{itemize}

Der NameService besteht aus der Hauptkomponente und der ConnectionHandler Komponente (siehe Abbildung
\ref{fig:nameservice-component-diagram}).\\

Die Hauptkomponente enthält den eigentlichen NameService. Der hat eine Registry, die eine Map darstellt, in der Namen
auf Objektreferenzen abgebildet werden. Diese Registry ist Threadsafe, da mehrere Clients parallel auf diese
zugreifen müssen und diese eventuell verändern können.

Der NameService an sich ist ein Singleton, wodurch sichergestellt wird, dass nur eine zentrale Stelle existiert, die
die benötigten Informationen (Registry) enthält.

In der Hauptkomponente ist außerdem ein NameServiceStarter enthalten, der den NameService Server mit dem übergebenen
Port startet.\\

Die ConnectionHandler Komponente ist für die einkommenden Verbindungen zuständig. In der Komponente ist der Server, der
durch einen Prozess realisiert wird. Der Prozess lauscht auf dem Socket und nimmt eventuelle Client Anfragen entgegen.

Jede einkommende Client Anfrage startet einen neuen ClientRequestHandler Prozess.\\

Der ClientRequestHandler Prozess dekodiert die einkommende Nachricht des Clients und versucht diese zu bearbeiten.
Mit Hilfe des Protokolls wird entweder ein Resolve oder ein Rebind durchgeführt.

Bei einem Resolve wird die passende Objektreferenz aus der Registry des NameServices übergeben. Wenn keine gefunden
wird, wird als Antwort das leere Element an den Client übergeben.

Bei einem Rebind wird die mit übermittelte Objektreferenz mit dem gegebenen Namen in der Registry des NameServices
hinterlegt.\\

Wenn Fehler beim Bearbeiten der an den NameService Server übermittelten Nachrichten auftreten, wird die Nachricht an
sich verworfen und die Verbindung des Clients serverseitig abgebaut. Wenn Client Anfragen zu lange brauchen, werden
diese abbgebrochen und verworfen (timeout).

\subsubsection{Konfigurationsparameter}
\begin{itemize}
    \item Port des NameServices
    \item Timeout für einkommende Nachrichten in Sekunden (10s)
\end{itemize}

\subsection{IDL Compiler (Neptr)}
\subsubsection{Aufgabe und Verantwortung}
Der IDL Compiler hat die Aufgabe, eine gegebene Modulbeschreibung aus einer \texttt{.idl-Datei} im IDL Format einzulesen
und daraus Java-Code zu generieren.\\

Es wird eine Abstrakte Java Klasse generiert (ImplBase bzw. Stub). Diese wird auf serverseitig eingebunden und zu einer
konkreten Klasse abgeleitet, die die Methodenrümpfe implementiert.\\

Darüber hinaus soll der Compiler eine Proxy - Klasse für die Clientseite generieren, welche die Methodenaufrufe auf dem
entfernten Server Objekt weiterleitet und ausführt. Das Proxy Objekt wird mit der Abstrakten Klasse (Stub) im Client
per narrowCast Methode erstellt.

\subsubsection{Schnittstelle}
\begin{lstlisting}
public class Compiler {
    /**
     * Ueber die main - Methode der Klasse Compiler kann der Compiler ausgefuehrt werden.
     */
    public static void main(String[] args);
}
\end{lstlisting}
Zu übergebene Argumente sind:
\begin{itemize}
	\item args[0]: Pfad zur IDL - Datei
	\item args[1]: Pfad zum Ordner für die Ausgabedateien
\end{itemize}

Die erzeugten Binaries können wie folgt ausgeführt werden:\\

\texttt{./bin/neptr <IDL-Dateipfad> <Ausgabe-Ordner>}

\subsubsection{Entwurfsentscheidungen}
\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{Compiler_FDM.png}
    \caption[fdm-compiler]{Fachliches Daten Modell des IDL-Compilers}
    \label{fig:fdm-compiler}
\end{figure}

Der Compiler besteht aus vier Komponenten (siehe Abbildung \ref{fig:compiler-component-diagram}). In der
Hauptkomponente (Compiler) ist der eigentliche Compiler mit seiner Mainmethode. Diese wird nach außen frei gegeben.

Der Compiler benutzt den Parser um eine IDL-Datei zu parsen und daraus ein IDLModule zu erstellen (siehe Abbildung
\ref{fig:fdm-compiler}). Diese IDLModule beinhaltet alle Klassen. Jede Klasse hat eine Ansammlung von Methoden.
Der Compiler schreibt nachdem die IDL-Datei geparsed wurde alle erkannten Klassen im Modul der IDL-Datei mit Hilfe der
Translator an den angegeben Ausgabepfad.\\

Die Translator haben ein fest definiertes Interface. Dadurch können leichter neue Translator erstellt werden und
Translator ausgetauscht werden. Außerdem ist dadurch der Übersetzungsprozess logisch von der Syntax der zu übersetzenden
Klasse getrennt.
Es gibt insgesamt zwei Translators. Einen um die Stubs (ImplBase) zu erstellen und einen
um die Proxy Klassen zu erstellen. Die Translators sind also dafür zuständig die IDLModules zu kompilieren in die
gewünschten Java Klassen.\\

Die Parser Komponente und die IDLModel Komponente wurden mit Hilfe der vorgegeben Klassen aus der Aufgabe erstellt und
erweitert.

\subsection{mware lib}
\subsubsection{Aufgabe und Verantwortung}
Die Bibiothek / das Package mware lib stellt die Kernfunktionalität bereit.
Die Schnitstelle nach außen ist die Klasse ObjectBroker, die eine Referenz auf eine
Implementierung des NameService Protokolls hält.


\subsubsection{Schnittstelle}
\begin{lstlisting}
public NameService getNameService();
Gibt die Referenz auf das Proxyobjekt fuer den NameService an den Aufrufer.
public void shutDown();
Beendet den Object Request Broker und seine Dependencies.
\end{lstlisting}

\subsubsection{Entwurfsentscheidungen}
Der Object Request Broker wird gemäß Vorgabe in einer statischen Methode initialisiert.
Hierbei wird ein Nameservice Proxyobjekt erzeugt, und zur weiteren Verwendung referenziert.
Das Nameservice Proxyobjekt leitet alle Methodenaufrufe des NameService an eine entfernte
NameService Instanz per TCP weiter.

\subsubsection{Konfigurationsparameter}

\begin{itemize}
    \item host: Der Hostname des entfernten NameService
    \item Port: Der Port des entfernten NameService
	\item Debug: Konfiguriert, ob debug ausgaben geloggt werden sollen.
\end{itemize}


\end{document}